cmake_minimum_required(VERSION 2.8.9)

set (CMAKE_MODULE_PATH "${CMAKE_CURRENT_SOURCE_DIR}/cmake")

include(SetInstallDir)
include(SetRPath)

# Name and version of the component
# =================================
project(FooBar C)

set(FOOBAR_MAJOR_VERSION 0)
set(FOOBAR_MINOR_VERSION 7)
set(FOOBAR_PATCH_VERSION 0)
set(FOOBAR_VERSION
  ${FOOBAR_MAJOR_VERSION}.${FOOBAR_MINOR_VERSION}.${FOOBAR_PATCH_VERSION})

# Setup installation directories and make relative paths absolute 
# ===============================================================
setup_installation_directories()

# Allow the developer to select if Dynamic or Static libraries are built (fixed)
# ==============================================================================
option (BUILD_SHARED_LIBS "Build Shared Libraries" OFF)
if (BUILD_SHARED_LIBS)
  set (LIB_TYPE SHARED)
endif()

# Set up include-directories
# ==========================
include_directories(
  "${PROJECT_SOURCE_DIR}"   # to find foo/foo.h, foo/exports_foo.h
  "${PROJECT_BINARY_DIR}")  # to find foo/config.h

# Add sub-directories
# ===================
add_subdirectory(foo)

# RPATH settings
# ==============
setup_rpath()

# Add sub-directories
# ===================
add_subdirectory(bar)

# The interesting stuff goes here
# ===============================

# Add all targets to the build-tree export set
export(TARGETS foo bar
  FILE "${PROJECT_BINARY_DIR}/FooBarTargets.cmake")


# Build and install configurations ('fixed')
# ==========================================

# JEM: The Generation of FooBarConfig.cmake needs to know if dynamic linking is used
if (BUILD_SHARED_LIBS)
  set(FOOBAR_DYNAMIC_LINKING TRUE)
else()
  set(FOOBAR_DYNAMIC_LINKING FALSE)
endif()

set(AUTOGENERATED_STRING "This file is autogenerated do not modify")

# Export the package for use from the build-tree
# (this registers the build-tree with a global CMake-registry)
export(PACKAGE ${PROJECT_NAME})

message("LORT")
message("${INSTALL_CMAKE_DIR}")

# Create the FooBarConfig.cmake and FooBarConfigVersion files
file(RELATIVE_PATH REL_INCLUDE_DIR "${INSTALL_CMAKE_DIR}"
   "${INSTALL_INCLUDE_DIR}")

# JEM: This is used for installations - no hard coding of directories,
file(RELATIVE_PATH REL_BIN_DIR "${INSTALL_CMAKE_DIR}"
   "${INSTALL_BIN_DIR}")

# ... for the build tree
set(CONF_INCLUDE_DIRS "${PROJECT_SOURCE_DIR}" "${PROJECT_BINARY_DIR}")
set(CONF_LIBRARY_DIRS "") # For build tree, multiple configurations are used
configure_file(FooBarConfig.cmake.in
  "${PROJECT_BINARY_DIR}/FooBarConfig.cmake" @ONLY)

# FOOBAR_CMAKE_DIR is just a variable name, used in FooBarConfig.cmake.in

# ... for the install tree
set(CONF_INCLUDE_DIRS "\${FOOBAR_CMAKE_DIR}/${REL_INCLUDE_DIR}")
set(CONF_LIBRARY_DIRS "\${FOOBAR_CMAKE_DIR}/${REL_BIN_DIR}")       # JEM: Used for installations
configure_file(FooBarConfig.cmake.in
  "${PROJECT_BINARY_DIR}${CMAKE_FILES_DIRECTORY}/FooBarConfig.cmake" @ONLY)

# ... for both
configure_file(FooBarConfigVersion.cmake.in
  "${PROJECT_BINARY_DIR}/FooBarConfigVersion.cmake" @ONLY)

# Install the FooBarConfig.cmake and FooBarConfigVersion.cmake
install(FILES
  "${PROJECT_BINARY_DIR}${CMAKE_FILES_DIRECTORY}/FooBarConfig.cmake"
  "${PROJECT_BINARY_DIR}/FooBarConfigVersion.cmake"
  DESTINATION "${INSTALL_CMAKE_DIR}" COMPONENT dev)

# Install the export set for use with the install-tree
install(EXPORT FooBarTargets DESTINATION
  "${INSTALL_CMAKE_DIR}" COMPONENT dev)

# Add uninstall target, in linux simply issue xargs rm < install_manifest.txt
configure_file(
    "${CMAKE_CURRENT_SOURCE_DIR}/cmake/cmake_uninstall.cmake.in"
    "${CMAKE_CURRENT_BINARY_DIR}/cmake/cmake_uninstall.cmake"
    IMMEDIATE @ONLY)

add_custom_target(uninstall
    COMMAND ${CMAKE_COMMAND} -P
    ${CMAKE_CURRENT_BINARY_DIR}/cmake/cmake_uninstall.cmake)
